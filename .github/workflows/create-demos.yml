name: Create Demo Recordings

on:
  push:
    branches:
      - main
    paths:
      # Workflow itself
      - '.github/workflows/create-demos.yml'

      # Recording scripts and framework (triggers demo regeneration)
      - 'scripts/record-*-demo.sh'
      - 'scripts/lib/demo-framework.sh'

      # Note: Tool source changes don't auto-trigger (tools are now submodules)
      # Use workflow_dispatch to manually trigger demo regeneration

  workflow_dispatch:  # Manual trigger
    inputs:
      tool:
        description: 'Tool to record demo for (leave empty for all tools)'
        required: false
        type: string

# Cancel in-progress runs when new commits are pushed
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  create-demos:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need previous commit to detect changes
          submodules: recursive  # Checkout tool submodules for demo recording

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Rust (for building Rust tools and agg)
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Cargo and agg binary
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-cargo-agg-v1.4.3
          restore-keys: |
            ${{ runner.os }}-cargo-agg-

      - name: Install asciinema
        run: |
          sudo apt-get update
          sudo apt-get install -y asciinema

      - name: Install agg (asciinema GIF generator)
        run: |
          # Only install if not already cached
          if ! command -v agg &> /dev/null; then
            cargo install --git https://github.com/asciinema/agg
          else
            echo "agg already installed (cached)"
          fi

      - name: Discover and record demos
        env:
          ASCIINEMA_INSTALL_ID: ${{ secrets.ASCIINEMA_INSTALL_ID }}
          TARGET_TOOL: ${{ github.event.inputs.tool }}
        run: |
          # Smart detection: only record demos for tools that need it
          if [ -n "$TARGET_TOOL" ]; then
            # Manual trigger: record specific tool
            TOOLS=("$TARGET_TOOL")
            echo "Manual trigger: recording demo for $TARGET_TOOL"
          else
            # Auto-detect tools that need demo recording
            TOOLS=()

            # Get changed files in this push
            CHANGED_FILES=""
            if git rev-parse HEAD^ >/dev/null 2>&1; then
              CHANGED_FILES=$(git diff --name-only HEAD^ HEAD)
            fi

            # Check each tool with a recording script
            for script in scripts/record-*-demo.sh; do
              if [ ! -f "$script" ]; then
                continue
              fi

              # Extract tool name from script filename
              tool=$(basename "$script" | sed 's/^record-//' | sed 's/-demo\.sh$//')
              tool_path="tools/$tool"

              # Check if tool directory exists (tools are git submodules in tools/)
              if [ ! -d "$tool_path" ]; then
                echo "  → $tool: Directory not found at $tool_path (skipping)"
                continue
              fi

              SHOULD_RECORD=false

              # Reason 1: Demo files are missing
              if [ ! -f "$tool_path/demo.cast" ] || [ ! -f "$tool_path/demo-url.txt" ] || [ ! -f "$tool_path/docs/demo.gif" ]; then
                echo "  → $tool: Demo files missing (will record)"
                SHOULD_RECORD=true
              fi

              # Reason 2: Tool implementation changed (check tools/ path)
              if [ -n "$CHANGED_FILES" ]; then
                if echo "$CHANGED_FILES" | grep -q "^tools/$tool/"; then
                  echo "  → $tool: Implementation changed (will record)"
                  SHOULD_RECORD=true
                fi
              fi

              # Reason 3: Recording script changed
              if [ -n "$CHANGED_FILES" ]; then
                if echo "$CHANGED_FILES" | grep -q "^scripts/record-${tool}-demo\.sh$"; then
                  echo "  → $tool: Recording script changed (will record)"
                  SHOULD_RECORD=true
                fi
              fi

              if [ "$SHOULD_RECORD" = true ]; then
                TOOLS+=("$tool")
              fi
            done
          fi

          echo "Found ${#TOOLS[@]} tool(s) to record:"
          printf '%s\n' "${TOOLS[@]}"

          # Record demos for each tool
          for tool in "${TOOLS[@]}"; do
            tool_path="tools/$tool"
            echo "================================"
            echo "Recording demo for: $tool (at $tool_path)"
            echo "================================"

            # Install dependencies based on tool type
            if [ -f "$tool_path/package.json" ]; then
              echo "Installing npm dependencies for $tool..."
              cd "$tool_path"
              npm install
              cd ../..
            elif [ -f "$tool_path/Cargo.toml" ]; then
              echo "Building Rust release for $tool..."
              cd "$tool_path"
              cargo build --release
              cd ../..
            fi

            # Run the recording script
            if [ -f "scripts/record-${tool}-demo.sh" ]; then
              cd "$tool_path"
              bash "../../scripts/record-${tool}-demo.sh"
              cd ../..
            else
              echo "Warning: No recording script found for $tool"
            fi
          done

      - name: Make recordings public (optional)
        if: false  # Set to true to enable auto-publishing recordings
        env:
          ASCIINEMA_API_TOKEN: ${{ secrets.ASCIINEMA_API_TOKEN }}
        run: |
          # NOTE: Asciinema uploads are "unlisted" by default (accessible via link, not searchable)
          # For our use case this is sufficient since we embed links in documentation.
          #
          # To make recordings fully public/searchable on asciinema.org, uncomment this step:
          # 1. Generate API token at https://asciinema.org/user/edit
          # 2. Add ASCIINEMA_API_TOKEN to GitHub repository secrets
          # 3. Set "if: false" to "if: true" above
          #
          # The code below will make all uploaded recordings public:

          if [ -n "$ASCIINEMA_API_TOKEN" ]; then
            # Tools are git submodules in tools/ directory
            for tool_path in tools/*/; do
              tool_path=${tool_path%/}  # Remove trailing slash
              tool_name=$(basename "$tool_path")

              if [ -f "$tool_path/demo-url.txt" ]; then
                URL=$(cat "$tool_path/demo-url.txt")
                RECORDING_ID=$(echo "$URL" | grep -oP 'https://asciinema.org/a/\K[a-zA-Z0-9]+')

                if [ -n "$RECORDING_ID" ]; then
                  echo "Making recording public for $tool_name (ID: $RECORDING_ID)..."
                  curl -s -X PATCH "https://asciinema.org/api/asciicasts/$RECORDING_ID" \
                    -H "Authorization: Bearer $ASCIINEMA_API_TOKEN" \
                    -H "Content-Type: application/json" \
                    -d '{"public": true}' || echo "Failed to make public"
                fi
              fi
            done
          else
            echo "ASCIINEMA_API_TOKEN not set - skipping"
          fi

      - name: Copy demos to VitePress public directory
        run: |
          # Copy demo GIFs to VitePress public directory for GitHub Pages
          # Tools are git submodules in tools/ directory
          for tool_path in tools/*/; do
            tool_path=${tool_path%/}
            tool_name=$(basename "$tool_path")

            if [ -f "$tool_path/docs/demo.gif" ]; then
              mkdir -p "docs/public/$tool_name"
              cp "$tool_path/docs/demo.gif" "docs/public/$tool_name/demo.gif"
              echo "✓ Copied demo to docs/public/$tool_name/demo.gif"
            fi
          done

      - name: Update READMEs with demo embeds
        run: |
          # Update each tool's README with embedded GIF and asciinema link
          # Tools are git submodules in tools/ directory
          for tool_path in tools/*/; do
            tool_path=${tool_path%/}  # Remove trailing slash
            tool_name=$(basename "$tool_path")

            # Skip if not a tool directory
            if [ ! -f "$tool_path/README.md" ]; then
              continue
            fi

            # Skip if no demo files
            if [ ! -f "$tool_path/docs/demo.gif" ]; then
              continue
            fi

            echo "Updating README for $tool_name..."

            # Get asciinema URL if available
            ASCIINEMA_URL="#"
            if [ -f "$tool_path/demo-url.txt" ]; then
              ASCIINEMA_URL=$(cat "$tool_path/demo-url.txt" | tr -d '\n')
            fi

            # Update README Demo section
            # Replace placeholder with embedded GIF and real asciinema link
            if grep -q "## Demo" "$tool_path/README.md"; then
              # Create updated demo section
              {
                echo "## Demo"
                echo ""
                echo "![Demo](docs/demo.gif)"
                echo ""
                echo "**[▶ View interactive recording on asciinema.org]($ASCIINEMA_URL)**"
                echo ""
                echo "> Try it online: [![Open in StackBlitz](https://developer.stackblitz.com/img/open_in_stackblitz.svg)](https://stackblitz.com/github/tuulbelt/tuulbelt/tree/main/$tool_name)"
              } > /tmp/demo-section.md

              # Replace Demo section in README (from ## Demo to next ##)
              awk '/^## Demo$/{p=1} p{if(/^## / && !/^## Demo$/){p=0}} !p' "$tool_path/README.md" > /tmp/readme-without-demo.md

              # Find where to insert (before ## License)
              awk '/^## License$/{print "";system("cat /tmp/demo-section.md");print ""} {print}' /tmp/readme-without-demo.md > "$tool_path/README.md.new"

              mv "$tool_path/README.md.new" "$tool_path/README.md"

              echo "✓ Updated README for $tool_name"
            fi
          done

      - name: Update VitePress docs with demo links
        run: |
          # Update VitePress documentation index pages with asciinema links
          # Tools are git submodules in tools/ directory
          for tool_path in tools/*/; do
            tool_path=${tool_path%/}  # Remove trailing slash
            tool_name=$(basename "$tool_path")

            # Skip if no VitePress docs exist
            if [ ! -f "docs/tools/$tool_name/index.md" ]; then
              continue
            fi

            # Skip if no demo URL
            if [ ! -f "$tool_path/demo-url.txt" ]; then
              continue
            fi

            echo "Updating VitePress docs for $tool_name..."

            # Get asciinema URL
            ASCIINEMA_URL=$(cat "$tool_path/demo-url.txt" | tr -d '\n')
            INDEX_FILE="docs/tools/$tool_name/index.md"

            # Pattern 1: Update existing asciinema.org URL
            sed -i "s|\*\*\[▶ View interactive recording on asciinema\.org\](https://asciinema\.org/a/[^)]*)\*\*|\*\*[▶ View interactive recording on asciinema.org]($ASCIINEMA_URL)\*\*|g" "$INDEX_FILE"

            # Pattern 2: Update placeholder (#) links
            sed -i "s|\*\*\[▶ View interactive recording on asciinema\.org\](#)\*\*|\*\*[▶ View interactive recording on asciinema.org]($ASCIINEMA_URL)\*\*|g" "$INDEX_FILE"

            # Pattern 3: Replace placeholder text with proper demo structure
            # This handles "Demo recording will be generated automatically..."
            if grep -q "Demo recording will be generated automatically" "$INDEX_FILE"; then
              # Create the proper demo section content
              DEMO_SECTION="See the tool in action:\n\n![${tool_name} Demo](/${tool_name}/demo.gif)\n\n**[▶ View interactive recording on asciinema.org]($ASCIINEMA_URL)**"

              # Replace the placeholder line
              sed -i "s|Demo recording will be generated automatically after merge via GitHub Actions\.|$DEMO_SECTION|g" "$INDEX_FILE"
              sed -i "s|Demo recording will be generated automatically after merge via GitHub Actions|$DEMO_SECTION|g" "$INDEX_FILE"
            fi

            echo "✓ Updated VitePress docs for $tool_name"
          done

      - name: Commit demo files to submodules
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Configure git to use GITHUB_TOKEN for authentication
          git config --global url."https://x-access-token:${GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/"

          # First, commit changes to each standalone tool repository (submodules)
          for tool_path in tools/*/; do
            tool_path=${tool_path%/}
            tool_name=$(basename "$tool_path")

            cd "$tool_path"

            # Check if there are changes to demo files
            if git status --porcelain | grep -E "(demo.cast|demo.gif|demo-url.txt|README.md)" > /dev/null; then
              echo "Committing demo updates for $tool_name to standalone repo..."

              git add demo.cast docs/demo.gif demo-url.txt README.md 2>/dev/null || true

              if ! git diff --staged --quiet; then
                git commit -m "docs: update demo recording with Title Case format" \
                           -m "Demo regenerated by create-demos workflow." \
                           -m "[skip ci]"
                git push origin main
                echo "✓ Pushed demo updates for $tool_name"
              else
                echo "  No staged changes for $tool_name"
              fi
            else
              echo "  No demo changes for $tool_name"
            fi

            cd ../..
          done

      - name: Commit demo files to meta repo
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Update submodule references and meta repo docs
          git add tools/*/  # Update all submodule pointers
          git add docs/public/*/demo.gif docs/tools/*/index.md || true

          if git diff --staged --quiet; then
            echo "No changes to commit in meta repo"
          else
            git commit -m "docs: update demo recordings and submodule references"

            # Clean up unstaged changes (build artifacts from npm install, cargo build)
            echo "Cleaning up build artifacts before pull..."
            git checkout -- . 2>/dev/null || true
            git clean -fd 2>/dev/null || true

            # Pull latest changes with rebase to avoid conflicts
            git pull --rebase origin main

            # Push changes
            git push
          fi
